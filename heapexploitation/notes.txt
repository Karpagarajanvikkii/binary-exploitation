tcache chunk metadata:-
free chunk:-

prev_size
 size inside size(A-if it is from main arena or not,M-whether the chunk was mmaped or not,p indicates if the previous chunk is free or  in use , its called PREV_INUSE
next:- pointer to the next chunk 
key:- points back to the original structure to check for double free

there are two arrays in tcache:-

counts and entries 

7 chunks is the limit of tcache 
if it cant go in tcache it will be put into fastbins, if the m bit is set it will call munmap to free it
if it doesnt go into tcache and smallbins it will go into unsorted bins
if it the chunk for the request size isnt found in fastbins we will consolidate fast bins then we will go through unsorted bin and if something fits we will use that, if the chunk is not large enough to satisfy the request we will place it into smallbins or largebins according to size,
if the request is still not satisfied we will look into largebins which will be of descending order the first chunk is the largest and if an chunk is of the same size that exists in largebins we add it after that 
if the largebins hasnt been filled or the request is not satisfied we will create the chunk from the wilderness, wilderness:- a fake chunk at the end of the data segment to store available space 

small bin chunk metadata:-
free chunk:-
prev_size:- size of previous chunk(in-memory) only taken into account if the current chuunk is free
size:- size of current chunk P bit:-indicates if previous chunk is in use 
fd:- forward pointer to the next chunk (in-memory)
bk:- backward pointer to the previous chunk in memory 
fd_nextsize
bk_nextsize


Consolidation:-
consolidation is why a doubly linked list is advantageous 
combines two neighbouring adjacent chunks





consolidation occurs when:-
when a chunk is freed 
when a chunk is malloc'd

consolidation requires removal entry when merging occurs

consolidation occurs both forward and backward 
the P bit must be cleared for a chunk to be consolidated


malloc- 
Bin access:-
there must be a global heap lock so that multiple threads dont try to access the heap at the same time thats the reason tcache was added, tcache acts as a layer where every thread gets it own cache

fastbins:-
its caching layer for the heap itself 
singly linked list with safe-linking- similar to tcache
bin lists can grow  to an unlimited size while tcache has a maximum of 7 chunks 
if that chunk is upto 88bytes in size it will end up in fastbin if it falls within the fastbin's size range 
bins size up to 88 bytes 
P bit is never cleared for the fast bins so it prevents consolidations 
only checks the top chunk for the double free 

the next to consider if the request isnt satisified yet is smallbins

smallbins:-

doubly linked lists 
FIFO manner
fast access, but capable of consolidation

Fastbins - clearing and consolidating 

consolidating fastbins if the malloc request is large like over 1024 bytes in size  to prevent fragmentation 
 
if a chunk is freed around ~65kb in size (choosen heuristically)

next step is to check/sort unsorted bins 

Unsorted bin:-

Doubly linked list 
Holds small bins and large bin values(anything that couldnt go in fast bins)

On malloc:

Unsorted bin chunks are checked 

if chunk does not satisfy malloc, it is placed in small bin or large bin according to the chunk's size 

Large bins:-
Doubly linked lists 
bins consists of range of sizes 
chunks in each bin are sorted by size , largest first(descending)

bk_nextsize is used to jump up in size category quickly 
fd_nextsize 
head pointers corresponds to size ranges 

if the allocation request is still not satisfied and the request is too huge it will mmaped 
or if its a reasonable size we can allocate it from the wilderness 




