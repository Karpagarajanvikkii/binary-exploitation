Initial analysis:-
After looking at the challenge we find that we can buy planes,build airports, sell them, list all the planes in an airport and fly planes to different airports
we use IDA to decompile the functions to find any vulnerabilities that will lead to code execution,we see the buyplane and buildairport stores pointers of already existing 
objects on an array of pointers  in bss and even after freed(i.e selling plane or airport) the pointer remains so we find an use after free,when we sell a airport it also frees the planes that were in it 
we find that the function for buyplane keeps company names in the array of pointers and it doesnt check if we pick an index greater than 5 so we think how to use that to get a leak as the plane pointer of arrays
and airport pointer of arrays lie closer in memory in bss so the plane pointer array is at 0x202020 and the airport pointer of array is at 0x202080 so if we pick a company name like 4 its far in memory than 1 so we calculate the index 
that's needed to point to an existing(allocated) or freed airport and after calculating we find that if we want to make the plane object's company point to the first airport in the array of pointers for airport it would be 13 
so knowing this we can get a heap and libc leak then calculate a one_gadget address from libc base and overwrite a function pointer to get a shell, so lets go over to the exploitation part

Exploitation:-

so the idea is to buy three airports first and free the first two so main arena address is pushed into the plane object which points to the freed airport but its pointer is still there because of an use after free, so the company name of the 
plane object with index 14 when buying will have a libc main arena address  because it was freed, we use the fly plane to an airport function to make the plane go to the not freed airport and use the list planes function to get the libc leak, then we calculate the libc base and 
we calculate one_gadget's address to achieve a shell, now we need to get a heap address leak and calculate the heap base then we can overwrite a plane objects function pointer with the one_gadget's address to pop a shell
in order to get a heap leak,we use the same strategy  we used to get a libc but instead of making the plane object point to an freed airport we make it point to the unfreed airport with the index of 15 when buying a plane
so that we can get a heap leak as the airport is not freed and it will have a address allocated on the heap so we buy a plane with the index 15,fly it to the unfreed airport 
then use the list planes function to get the heap leak in its company section, then we calculate the heap_base, now that we have libc base address and the heap's base address, we make breakpoints in certain points for functions
and find out where the function pointer of the plane object is located in memory, we find that to be 0x170 from base as it contained the address of freeing the plane which we know from decompiling with IDA 
so we confirm that it is the function pointer that needs to be overwritten with the one_gadget's address, the interesting part in the exploitation process happens here we sell the two planes first so now they are added to the fastbin list as the size of an plane object is within fastbins range 
but when we sell the airport the planes are freed again, now a double free happens because of the UAF vulnerability, now we buy three plane's the first one points a bit back in memory from the P4 plane objects function pointer so we can overwrite it with the one_gadget's address
the second P3 and P4, the function pointer we  overwrite is of P4's, then we build an fake airport object that does the overwrite of the function pointer of P4 with the one gadget address because of UAF, we pad it then we also keep the prev plane pointer to avoid crash and for the exploit to work properly
and then we write the one gadget address and then sell the P4 plane that calls free but as we have overwritten the plane object's function pointer the address of the one_gadget is called and a shell is popped.
 
